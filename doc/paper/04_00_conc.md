# Conclusão

## Interfaces e Comandos Remotos

O nodo em execução apresenta quatro tipos de interfaces que podem ser utilizadas para a visualização de informação, e três para serem utilizadas para a entrada de informação. A primeira interface é a comum de um programa *CLI* onde, por um ambiente de linha de comando, o usuário pode visualizar as saídas que o nodo imprime. Nesta interface, a única entrada aceita é o da escolha de parâmetros, ao iniciar o nodo. Uma vez iniciado, o usuário da máquina pode terminar o processo forçadamente de acordo com a configuração de seu ambiente (`Ctrl+C`, por padrão no *Windows*). A segunda interface é o arquivo salvo como uma impressão idêntica àquelas informações que são impressas na primeira interface, no qual um usuário da máquina pode ler as informações do arquivo. A terceira interface é a interface remota de comunicação, uma conexão *telnet* via *TCP* com os administradores, os quais podem se relacionar com o nodo de maneira similar àquela dos programas *CLI*, com inserção de comandos, subcomandos e parâmetros e, possivelmente, leitura das respostas textuais do nodo. A quarta interface é uma conexão segundo o protocolo *P2P* do *Bitcoin*, via *TCP*, no qual um nodo externo pode conectar-se a ela e realizar determinas interações com o nodo, segundo o que é previsto na máquina de estado da sua representação interna de um *peer*.

É por meio da segunda e da terceira interface, os arquivos de *log* e textos no terminal *telnet* respectivamente, que os resultados foram observados. A produção de resultados deriva da interação intencional administrativa, por comandos do *admin*.

## Nodo de Roteamento

A funcionalidade do *codec* foi observada através da interface com o *admin*, onde foram inseridas mensagens serializadas[^1002] e então observados os dados em um formato estrutural e, se possível, validado. Pôde-se também visualizar erros caso ocorresse algum problema na desserialização, incluindo a cadeia de dependências de todas as estruturas atreladas àquele erro. Uma das maneiras de se testar alguns tipos de des/serialização é através do comando `cargo test`, comando específico de um ambiente padrão do *Rust*, para que as funções atribuídas com a marcação *test* sejam executadas e suas falhas, caso ocorram, sejam relatadas. As mensagens serializadas de teste contidas no projeto foram obtidas da documentação em \citeonline{btcref}.

[^1002]: Mensagem em bytes, transmitida na rede do *Bitcoin*.

A funcionalidade de roteamento foi observada através de impressão textual em arquivos de *log*, os quais foram produzidos indiretamente de um comando de um *admin*, como `peer add --addr=189.38.88.105:8333`[^350], um procedimento que, como um todo, imprimirá informações ao longo de sua existência no arquivo de *log*. De início, o *worker* inicia uma conexão *TCP* e então, sendo este um comportamento esperado, o *peer* transmite os dados de "*Version*"{} que contém algumas informações que auxiliarão comunicações futuras, como a especificação da versão do protocolo que o nodo, em primeira pessoa, se baseia. Durante cada recebimento de uma mensagem via *socket*, é impresso informações relativas a ela, como se o número de *bytes* necessários para o conhecimento do *header* já estão disponíveis em um *buffer* específico, e se a mensagem recebida é válida segundo algumas verificações iniciais. Portanto, sendo observados informações referentes à transmissão e recebimento de mensagens e valores válidos que foram produzidos pelo nodo externo, infere-se de que a funcionalidade de roteamento funciona como o esperado.

[^350]: Comando referente adição de um nodo, o terceiro parâmetro é referente ao endereço de IP de um nodo externo. Este nodo, utilizado neste caso, foi o nodo brasileiro com o melhor *ranking* no site \citeonline{bitnodes}.

Após verificado a capacidade de conexão do nodo desenvolvido com outros nodos da rede, foi testado a sua capacidade de se conectar simultaneamente a múltiplos nodos. para isto, o *admin* iniciou os comandos para a conexão com vários nodos externos e então entrou com o comando `peer list`[^132], observando assim, em sua interface, uma lista coerente com as conexões que efetuou.

[^132]: Comando que retorna a quantidade de *peers* e *admins* conectados e suas informações básicas.

## Estruturação da *Blockchain*

Os procedimentos do *download* dos dados da *blockchain* giram em torno tanto do *codec* e roteamento quanto do *actor blockchain*. Este, possuindo uma máquina própria e os canais necessários para conseguir se comunicar com os *workers* e portanto realizar pedidos para envios de mensagens para outros nodos através de seus *peers*, pode criar expectativas de respostas específicas para *peers* específicos, podendo assim, tanto realizar *upload/download* de informações quanto avaliar a conexão e comportamento dos outros *peers* a fim de indicar para o nodo como um todo que pode ser desejável iniciar conexões com novos nodos e terminar conexões com nodos específicos. É importante ressaltar que, apesar da existência de funcionalidades do entorno deste procedimento específico existirem[^333], o próprio *actor* permaneceu em faze de planejamento comportamental e não teve tal implementação concluída.

[^333]: Como a elaboração, des/serialização e comunicação das mensagens de *GetHeaders/GetData* e da resposta esperada "*Header*"{}/"*Block*"{}, que são utilizadas para requisitar e receber, respectivamente, informações do encadeamento de cabeçalhos e dos blocos da *blockchain*.

## *Memory-safety* e Assincronismo

O código implementado do nodo foi compilado sem erros pelo compilador da linguagem *Rust*. Devido ao fato do código não declarar escopos *unsafe* de forma explícita, pode-se deduzir que tal programa traz fortes garantias de ser *memory-safe*. Dos escopos *unsafe* das bibliotecas utilizadas como dependências, segundo as pesquisas referenciadas em \REF{n2:rust} -- metodologias de verificação estão atualmente sendo elaboradas e executadas, de forma que existe a possibilidade da garantia de segurança de memória por construção ser fortalecida de acordo com o resultado destas pesquisas.

Durante a implementação, foi despendido de forma recorrente uma grande quantidade de esforço para resolver problemas de *lifetimes* dos escopos com referência e *ownsership* sobre memórias, e em partes deste processo, que se mostra através de impedimentos de compilações, foi obtido as garantias por construção supracitadas.

A funcionalidade de assincronismo foi observada através do comando de *admin* `debug wait 10`[^106] seguido do comando `debug wait 1`, sendo impresso na interface do *admin* respostas em ordem contrária aos comandos enviados. Portanto, verificou-se um caso em que o processo desempenhou uma tarefa de forma assíncrona, onde o *admin* não precisa bloquear uma *thread* enquanto espera pelas respostas de pedidos arbitrários a serem executados.

[^106]: Quando este comando é recebido por um *worker* o mesmo esperará o tempo (em segundos) representado pelo terceiro parâmetro da entrada.

## Trabalhos Futuros

O trabalho foi desenvolvido incrementalmente, sendo compilado com sucesso durante fases intermediárias, com o objetivo de facilitar e auxiliar futuros desenvolvimentos. Portanto, este possui a intenção futura de disponibilizar um nodo completo assíncrono e *memory-safe* para uso gratuito e irrestrito. Para isto, será necessário continuar o desenvolvimento de funções ainda primordiais para o funcionamento de um nodo completo, como: a validação total das transações através de bibliotecas como indicado em \citeonline{consensus} e dos blocos; o gerenciamento da *blockchain* como planejado no \REF{n3:bchain}; a *API* específica para carteiras e exploradores de *blockchain*; mineração opcional de blocos; e testes exaustivos de segurança do nodo e de suas funcionalidades.
